{"version":3,"sources":["../../../projects/ngx-page-scroll/src/lib/ngx-page-scroll.directive.ts","../../../projects/ngx-page-scroll/src/lib/ngx-page-scroll.module.ts"],"names":["NgxPageScrollDirective","pageScrollService","router","document","this","pageScrollAdjustHash","pageScrollFinish","EventEmitter","prototype","ngOnChanges","changes","pageScrollInstance","undefined","ngOnDestroy","stop","getPageScrollTarget","pageScrollTarget","href","fragment","generatePageScrollInstance","options","scrollTarget","pageScroll","namespace","pageScrollHorizontal","verticalScrolling","pageScrollOffset","scrollOffset","pageScrollInterruptible","interruptible","pageScrollInView","scrollInView","pageScrollEasing","easingLogic","pageScrollDuration","duration","pageScrollSpeed","speed","scrollFinishListener","create","pushRouterState","pageScrollOptions","substr","navigate","queryParamsHandling","scroll","start","handleClick","clickEvent","_this","routerLink","urlTree","parseUrl","createUrlTree","isActive","events","pipe","filter","routerEvent","NavigationEnd","NavigationError","NavigationCancel","take","subscribe","setTimeout","Directive","args","selector","host","(click)","PageScrollService","Router","decorators","type","Optional","Inject","DOCUMENT","Input","Output","NgModule","declarations","imports","NgxPageScrollCoreModule","exports"],"mappings":"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","sourcesContent":["/* tslint:disable:no-host-metadata-property directive-selector */\n\nimport {\n  Directive,\n  EventEmitter,\n  Inject,\n  Input,\n  OnChanges,\n  OnDestroy,\n  Optional,\n  Output,\n  SimpleChanges\n} from '@angular/core';\nimport { NavigationCancel, NavigationEnd, NavigationError, Router, UrlTree } from '@angular/router';\nimport { DOCUMENT } from '@angular/common';\n\nimport { EasingLogic, PageScrollInstance, PageScrollOptions, PageScrollService } from 'ngx-page-scroll-core';\nimport { filter, take } from 'rxjs/operators';\n\n@Directive({\n  selector: '[pageScroll]',\n  host: {\n    '(click)': 'handleClick($event)',\n  },\n})\nexport class NgxPageScrollDirective implements OnChanges, OnDestroy {\n\n  @Input()\n  public routerLink: any;\n\n  @Input()\n  public href: string;\n\n  @Input()\n  public fragment: string;\n\n  @Input()\n  public pageScrollTarget: string;\n\n  @Input()\n  public pageScrollHorizontal: boolean;\n\n  @Input()\n  public pageScrollOffset: number;\n\n  @Input()\n  public pageScrollDuration: number;\n\n  @Input()\n  public pageScrollSpeed: number;\n\n  @Input()\n  public pageScrollEasing: EasingLogic;\n\n  @Input()\n  public pageScrollInterruptible: boolean;\n\n  @Input()\n  public pageScrollInView: boolean;\n\n  @Input()\n  public pageScrollAdjustHash = false;\n\n  @Input()\n  public pageScroll: string;\n\n  @Output()\n  pageScrollFinish: EventEmitter<boolean> = new EventEmitter<boolean>();\n\n  private pageScrollInstance: PageScrollInstance;\n  private document: Document;\n\n  constructor(private pageScrollService: PageScrollService, @Optional() private router: Router, @Inject(DOCUMENT) document: any) {\n    this.document = (document as Document);\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    // Some inputs changed, reset the pageScrollInstance\n    this.pageScrollInstance = undefined;\n  }\n\n  ngOnDestroy(): void {\n    if (this.pageScrollInstance) {\n      this.pageScrollService.stop(this.pageScrollInstance);\n    }\n  }\n\n  private getPageScrollTarget(): string {\n    return this.pageScrollTarget || this.href || (this.fragment ? '#' + this.fragment : '');\n  }\n\n  private generatePageScrollInstance(): PageScrollInstance {\n    if (this.pageScrollInstance === undefined || this.pageScrollInstance === null) {\n      const options: PageScrollOptions = {\n        document: this.document,\n        scrollTarget: this.getPageScrollTarget(),\n      };\n\n      if (this.pageScroll) {\n        options.namespace = this.pageScroll;\n      }\n      if (this.pageScrollHorizontal !== undefined && this.pageScrollHorizontal !== null) {\n        options.verticalScrolling = !this.pageScrollHorizontal;\n      }\n      if (this.pageScrollOffset !== undefined && this.pageScrollOffset !== null) {\n        options.scrollOffset = this.pageScrollOffset;\n      }\n      if (this.pageScrollInterruptible !== undefined && this.pageScrollInterruptible !== null) {\n        options.interruptible = this.pageScrollInterruptible;\n      }\n      if (this.pageScrollInView !== undefined && this.pageScrollInView !== null) {\n        options.scrollInView = this.pageScrollInView;\n      }\n      if (this.pageScrollEasing) {\n        options.easingLogic = this.pageScrollEasing;\n      }\n      if (this.pageScrollDuration !== undefined && this.pageScrollDuration !== null) {\n        options.duration = this.pageScrollDuration;\n      }\n      if (this.pageScrollSpeed !== undefined && this.pageScrollSpeed !== null) {\n        options.speed = this.pageScrollSpeed;\n      }\n      if (this.pageScrollFinish) {\n        options.scrollFinishListener = this.pageScrollFinish;\n      }\n      this.pageScrollInstance = this.pageScrollService.create(options);\n    }\n\n    return this.pageScrollInstance;\n  }\n\n  private pushRouterState(): void {\n    if (this.pageScrollAdjustHash && typeof this.pageScrollInstance.pageScrollOptions.scrollTarget === 'string'\n      && (this.pageScrollInstance.pageScrollOptions.scrollTarget as string).substr(0, 1) === '#') {\n      // \"Navigate\" to the current route again and this time set the fragment/hash\n      this.router.navigate([], {\n        fragment: (this.pageScrollInstance.pageScrollOptions.scrollTarget as string).substr(1),\n        queryParamsHandling: 'preserve',\n      });\n    }\n  }\n\n  private scroll(): void {\n    const pageScrollInstance = this.generatePageScrollInstance();\n    this.pushRouterState();\n    this.pageScrollService.start(pageScrollInstance);\n  }\n\n  public handleClick(clickEvent: Event): boolean { // tslint:disable-line:no-unused-variable\n    if (this.routerLink && this.router !== null && this.router !== undefined) {\n      let urlTree: UrlTree;\n      if (typeof this.routerLink === 'string') {\n        urlTree = this.router.parseUrl(this.routerLink);\n      } else {\n        urlTree = this.router.createUrlTree(this.routerLink);\n      }\n      if (!this.router.isActive(urlTree, true)) {\n        // We need to navigate their first.\n        // Navigation is handled by the routerLink directive so we only need to listen for route change\n        this.router.events.pipe(filter(routerEvent => {\n            // We're only interested in successful navigations or when the navigation fails\n            return routerEvent instanceof NavigationEnd || routerEvent instanceof NavigationError\n              || routerEvent instanceof NavigationCancel;\n          }),\n          // Consume only one event, automatically \"unsubscribing\" from the event stream afterwards\n          take(1)\n        ).subscribe((routerEvent) => {\n          if (routerEvent instanceof NavigationEnd) {\n            // use a timeout to start scrolling as soon as the stack is cleared\n            setTimeout(() => {\n              this.scroll();\n            }, 0);\n          }\n        });\n\n        return false; // to preventDefault()\n      }\n    }\n    this.scroll();\n\n    return false; // to preventDefault()\n  }\n}\n","import { NgModule } from '@angular/core';\n\nimport { NgxPageScrollCoreModule } from 'ngx-page-scroll-core';\n\nimport { NgxPageScrollDirective } from './ngx-page-scroll.directive';\n\n@NgModule({\n  declarations: [\n    NgxPageScrollDirective,\n  ],\n  imports: [\n    NgxPageScrollCoreModule,\n  ],\n  exports: [\n    NgxPageScrollDirective,\n  ],\n})\nexport class NgxPageScrollModule {\n}\n"]}