import { Injectable, Optional, SkipSelf, isDevMode } from '@angular/core';
import { PageScrollConfig } from './ng2-page-scroll-config';
import { PageScrollUtilService as Util } from './ng2-page-scroll-util.service';
import * as ɵngcc0 from '@angular/core';
var PageScrollService = (function () {
    function PageScrollService() {
        var _this = this;
        this.runningInstances = [];
        this.onInterrupted = {
            report: function (event, pageScrollInstance) {
                if (!pageScrollInstance.interruptible) {
                    // Non-interruptible anyway, so do not stop anything
                    return;
                }
                var shouldStop = true;
                if (event.type === 'keyup') {
                    // Only stop if specific keys have been pressed, for all others don't stop anything
                    if (PageScrollConfig._interruptKeys.indexOf(event.keyCode) === -1) {
                        // The pressed key is not in the list of interrupting keys
                        shouldStop = false;
                    }
                }
                else if (event.type === 'mousedown') {
                    // For mousedown events we only stop the scroll animation of the mouse has
                    // been clicked inside the scrolling container
                    if (!pageScrollInstance.scrollingViews.some(function (scrollingView) { return scrollingView.contains(event.target); })) {
                        // Mouse clicked an element which is not inside any of the the scrolling containers
                        shouldStop = false;
                    }
                }
                if (shouldStop) {
                    _this.stopAll(pageScrollInstance.namespace);
                }
            }
        };
        if (PageScrollService.instanceCounter > 0 &&
            (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode()))) {
            console.warn('An instance of PageScrollService already exists, usually ' +
                'including one provider should be enough, so double check.');
        }
        PageScrollService.instanceCounter++;
    }
    PageScrollService.prototype.stopInternal = function (interrupted, pageScrollInstance) {
        var index = this.runningInstances.indexOf(pageScrollInstance);
        if (index >= 0) {
            this.runningInstances.splice(index, 1);
        }
        if (pageScrollInstance.interruptListenersAttached) {
            pageScrollInstance.detachInterruptListeners();
        }
        if (pageScrollInstance.timer) {
            // Clear/Stop the timer
            clearInterval(pageScrollInstance.timer);
            // Clear the reference to this timer
            pageScrollInstance.timer = undefined;
            pageScrollInstance.fireEvent(!interrupted);
            return true;
        }
        return false;
    };
    /**
     * Start a scroll animation. All properties of the animation are stored in the given {@link PageScrollInstance} object.
     *
     * This is the core functionality of the whole library.
     *
     * @param pageScrollInstance
     */
    PageScrollService.prototype.start = function (pageScrollInstance) {
        var _this = this;
        // Stop all possibly running scroll animations in the same namespace
        this.stopAll(pageScrollInstance.namespace);
        if (pageScrollInstance.scrollingViews === null || pageScrollInstance.scrollingViews.length === 0) {
            // No scrollingViews specified, thus we can't animate anything
            if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {
                console.warn('No scrollingViews specified, this ng2-page-scroll does not know which DOM elements to scroll');
            }
            return;
        }
        var startScrollPositionFound = false;
        // Reset start scroll position to 0. If any of the scrollingViews has a different one, it will be extracted next
        pageScrollInstance.startScrollPosition = 0;
        // Get the start scroll position from the scrollingViews (e.g. if the user already scrolled down the content)
        pageScrollInstance.scrollingViews.forEach(function (scrollingView) {
            if (Util.isUndefinedOrNull(scrollingView)) {
                return;
            }
            // Get the scrollTop or scrollLeft value of the first scrollingView that returns a value for its "scrollTop"
            // or "scrollLeft" property that is not undefined and unequal to 0
            var scrollPosition = pageScrollInstance.getScrollPropertyValue(scrollingView);
            if (!startScrollPositionFound && scrollPosition) {
                // We found a scrollingView that does not have scrollTop or scrollLeft 0
                // Return the scroll position value, as this will be our startScrollPosition
                pageScrollInstance.startScrollPosition = scrollPosition;
                startScrollPositionFound = true;
            }
        });
        var pageScrollOffset = pageScrollInstance.getCurrentOffset();
        // Calculate the target position that the scroll animation should go to
        var scrollTargetPosition = pageScrollInstance.extractScrollTargetPosition();
        pageScrollInstance.targetScrollPosition = Math.round((pageScrollInstance.verticalScrolling ? scrollTargetPosition.top : scrollTargetPosition.left) - pageScrollOffset);
        // Calculate the distance we need to go in total
        pageScrollInstance.distanceToScroll = pageScrollInstance.targetScrollPosition - pageScrollInstance.startScrollPosition;
        if (isNaN(pageScrollInstance.distanceToScroll)) {
            // We weren't able to find the target position, maybe the element does not exist?
            if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {
                console.log('Scrolling not possible, as we can\'t find the specified target');
            }
            pageScrollInstance.fireEvent(false);
            return;
        }
        // We're at the final destination already
        // OR we need to scroll down but are already at the end
        // OR we need to scroll up but are at the top already
        var allReadyAtDestination = Math.abs(pageScrollInstance.distanceToScroll) < PageScrollConfig._minScrollDistance;
        // Check how long we need to scroll if a speed option is given
        // Default executionDuration is the specified duration
        pageScrollInstance.executionDuration = pageScrollInstance.duration;
        // Maybe we need to pay attention to the speed option?
        if (!Util.isUndefinedOrNull(pageScrollInstance.speed) && Util.isUndefinedOrNull(pageScrollInstance.duration)) {
            // Speed option is set and no duration => calculate duration based on speed and scroll distance
            pageScrollInstance.executionDuration = Math.abs(pageScrollInstance.distanceToScroll) / pageScrollInstance.speed * 1000;
        }
        // We should go there directly, as our "animation" would have one big step
        // only anyway and this way we save the interval stuff
        var tooShortInterval = pageScrollInstance.executionDuration <= PageScrollConfig._interval;
        if (allReadyAtDestination || tooShortInterval) {
            if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {
                if (allReadyAtDestination) {
                    console.log('Scrolling not possible, as we can\'t get any closer to the destination');
                }
                else {
                    console.log('Scroll duration shorter that interval length, jumping to target');
                }
            }
            pageScrollInstance.setScrollPosition(pageScrollInstance.targetScrollPosition);
            pageScrollInstance.fireEvent(true);
            return;
        }
        // Register the interrupt listeners if we want an interruptible scroll animation
        if (pageScrollInstance.interruptible ||
            (Util.isUndefinedOrNull(pageScrollInstance.interruptible) && PageScrollConfig.defaultInterruptible)) {
            pageScrollInstance.attachInterruptListeners(this.onInterrupted);
        }
        // Let's get started, get the start time...
        pageScrollInstance.startTime = new Date().getTime();
        // .. and calculate the end time (when we need to finish at last)
        pageScrollInstance.endTime = pageScrollInstance.startTime + pageScrollInstance.executionDuration;
        pageScrollInstance.timer = setInterval(function (_pageScrollInstance) {
            // Take the current time
            var currentTime = new Date().getTime();
            // Determine the new scroll position
            var newScrollPosition;
            var stopNow = false;
            if (_pageScrollInstance.endTime <= currentTime) {
                // We're over the time already, so go the targetScrollPosition (aka destination)
                newScrollPosition = _pageScrollInstance.targetScrollPosition;
                stopNow = true;
            }
            else {
                // Calculate the scroll position based on the current time using the easing function
                newScrollPosition = Math.round(_pageScrollInstance.easingLogic.ease(currentTime - _pageScrollInstance.startTime, _pageScrollInstance.startScrollPosition, _pageScrollInstance.distanceToScroll, _pageScrollInstance.executionDuration));
            }
            // Set the new scrollPosition to all scrollingViews elements
            if (!_pageScrollInstance.setScrollPosition(newScrollPosition)) {
                // Setting the new scrollTop/scrollLeft value failed for all ScrollingViews
                // early stop the scroll animation to save resources
                stopNow = true;
            }
            // At the end do the internal stop maintenance and fire the pageScrollFinish event
            // (otherwise the event might arrive at "too early")
            if (stopNow) {
                _this.stopInternal(false, _pageScrollInstance);
            }
        }, PageScrollConfig._interval, pageScrollInstance);
        // Register the instance as running one
        this.runningInstances.push(pageScrollInstance);
    };
    /**
     * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.
     *
     * @param namespace
     * @returns {boolean}
     */
    PageScrollService.prototype.stopAll = function (namespace) {
        if (this.runningInstances.length > 0) {
            var stoppedSome = false;
            for (var i = 0; i < this.runningInstances.length; ++i) {
                var pageScrollInstance = this.runningInstances[i];
                if (Util.isUndefinedOrNull(namespace) || namespace.length === 0 ||
                    pageScrollInstance.namespace === namespace) {
                    stoppedSome = true;
                    this.stopInternal(true, pageScrollInstance);
                    // Decrease the counter, as we removed an item from the array we iterate over
                    i--;
                }
            }
            return stoppedSome;
        }
        return false;
    };
    PageScrollService.prototype.stop = function (pageScrollInstance) {
        return this.stopInternal(true, pageScrollInstance);
    };
    PageScrollService.instanceCounter = 0;
    /** @nocollapse */
    PageScrollService.ctorParameters = function () { return []; };
PageScrollService.ɵfac = function PageScrollService_Factory(t) { return new (t || PageScrollService)(); };
PageScrollService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PageScrollService, factory: function (t) { return PageScrollService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PageScrollService, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return PageScrollService;
}());
export { PageScrollService };
/* singleton pattern taken from https://github.com/angular/angular/issues/13854 */
export function NG2PAGESCROLL_SERVICE_PROVIDER_FACTORY(parentDispatcher) {
    return parentDispatcher || new PageScrollService();
}
export var NG2PAGESCROLL_SERVICE_PROVIDER = {
    provide: PageScrollService,
    deps: [[new Optional(), new SkipSelf(), PageScrollService]],
    useFactory: NG2PAGESCROLL_SERVICE_PROVIDER_FACTORY
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmcyLXBhZ2Utc2Nyb2xsLnNlcnZpY2UuanMiLCJzb3VyY2VzIjpbIm5nMi1wYWdlLXNjcm9sbC5zZXJ2aWNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUdNO0FBQ047QUFDQTs7Ozs7Z0RBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsLCBTa2lwU2VsZiwgaXNEZXZNb2RlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBQYWdlU2Nyb2xsQ29uZmlnIH0gZnJvbSAnLi9uZzItcGFnZS1zY3JvbGwtY29uZmlnJztcbmltcG9ydCB7IFBhZ2VTY3JvbGxVdGlsU2VydmljZSBhcyBVdGlsIH0gZnJvbSAnLi9uZzItcGFnZS1zY3JvbGwtdXRpbC5zZXJ2aWNlJztcbnZhciBQYWdlU2Nyb2xsU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFnZVNjcm9sbFNlcnZpY2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucnVubmluZ0luc3RhbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLm9uSW50ZXJydXB0ZWQgPSB7XG4gICAgICAgICAgICByZXBvcnQ6IGZ1bmN0aW9uIChldmVudCwgcGFnZVNjcm9sbEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYWdlU2Nyb2xsSW5zdGFuY2UuaW50ZXJydXB0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb24taW50ZXJydXB0aWJsZSBhbnl3YXksIHNvIGRvIG5vdCBzdG9wIGFueXRoaW5nXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNob3VsZFN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgc3RvcCBpZiBzcGVjaWZpYyBrZXlzIGhhdmUgYmVlbiBwcmVzc2VkLCBmb3IgYWxsIG90aGVycyBkb24ndCBzdG9wIGFueXRoaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChQYWdlU2Nyb2xsQ29uZmlnLl9pbnRlcnJ1cHRLZXlzLmluZGV4T2YoZXZlbnQua2V5Q29kZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcHJlc3NlZCBrZXkgaXMgbm90IGluIHRoZSBsaXN0IG9mIGludGVycnVwdGluZyBrZXlzXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRTdG9wID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIG1vdXNlZG93biBldmVudHMgd2Ugb25seSBzdG9wIHRoZSBzY3JvbGwgYW5pbWF0aW9uIG9mIHRoZSBtb3VzZSBoYXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVlbiBjbGlja2VkIGluc2lkZSB0aGUgc2Nyb2xsaW5nIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhZ2VTY3JvbGxJbnN0YW5jZS5zY3JvbGxpbmdWaWV3cy5zb21lKGZ1bmN0aW9uIChzY3JvbGxpbmdWaWV3KSB7IHJldHVybiBzY3JvbGxpbmdWaWV3LmNvbnRhaW5zKGV2ZW50LnRhcmdldCk7IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3VzZSBjbGlja2VkIGFuIGVsZW1lbnQgd2hpY2ggaXMgbm90IGluc2lkZSBhbnkgb2YgdGhlIHRoZSBzY3JvbGxpbmcgY29udGFpbmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0b3BBbGwocGFnZVNjcm9sbEluc3RhbmNlLm5hbWVzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoUGFnZVNjcm9sbFNlcnZpY2UuaW5zdGFuY2VDb3VudGVyID4gMCAmJlxuICAgICAgICAgICAgKFBhZ2VTY3JvbGxDb25maWcuX2xvZ0xldmVsID49IDIgfHwgKFBhZ2VTY3JvbGxDb25maWcuX2xvZ0xldmVsID49IDEgJiYgaXNEZXZNb2RlKCkpKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdBbiBpbnN0YW5jZSBvZiBQYWdlU2Nyb2xsU2VydmljZSBhbHJlYWR5IGV4aXN0cywgdXN1YWxseSAnICtcbiAgICAgICAgICAgICAgICAnaW5jbHVkaW5nIG9uZSBwcm92aWRlciBzaG91bGQgYmUgZW5vdWdoLCBzbyBkb3VibGUgY2hlY2suJyk7XG4gICAgICAgIH1cbiAgICAgICAgUGFnZVNjcm9sbFNlcnZpY2UuaW5zdGFuY2VDb3VudGVyKys7XG4gICAgfVxuICAgIFBhZ2VTY3JvbGxTZXJ2aWNlLnByb3RvdHlwZS5zdG9wSW50ZXJuYWwgPSBmdW5jdGlvbiAoaW50ZXJydXB0ZWQsIHBhZ2VTY3JvbGxJbnN0YW5jZSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnJ1bm5pbmdJbnN0YW5jZXMuaW5kZXhPZihwYWdlU2Nyb2xsSW5zdGFuY2UpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nSW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZ2VTY3JvbGxJbnN0YW5jZS5pbnRlcnJ1cHRMaXN0ZW5lcnNBdHRhY2hlZCkge1xuICAgICAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLmRldGFjaEludGVycnVwdExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWdlU2Nyb2xsSW5zdGFuY2UudGltZXIpIHtcbiAgICAgICAgICAgIC8vIENsZWFyL1N0b3AgdGhlIHRpbWVyXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHBhZ2VTY3JvbGxJbnN0YW5jZS50aW1lcik7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgcmVmZXJlbmNlIHRvIHRoaXMgdGltZXJcbiAgICAgICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS50aW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5maXJlRXZlbnQoIWludGVycnVwdGVkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IGEgc2Nyb2xsIGFuaW1hdGlvbi4gQWxsIHByb3BlcnRpZXMgb2YgdGhlIGFuaW1hdGlvbiBhcmUgc3RvcmVkIGluIHRoZSBnaXZlbiB7QGxpbmsgUGFnZVNjcm9sbEluc3RhbmNlfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSBjb3JlIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIHdob2xlIGxpYnJhcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFnZVNjcm9sbEluc3RhbmNlXG4gICAgICovXG4gICAgUGFnZVNjcm9sbFNlcnZpY2UucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHBhZ2VTY3JvbGxJbnN0YW5jZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBTdG9wIGFsbCBwb3NzaWJseSBydW5uaW5nIHNjcm9sbCBhbmltYXRpb25zIGluIHRoZSBzYW1lIG5hbWVzcGFjZVxuICAgICAgICB0aGlzLnN0b3BBbGwocGFnZVNjcm9sbEluc3RhbmNlLm5hbWVzcGFjZSk7XG4gICAgICAgIGlmIChwYWdlU2Nyb2xsSW5zdGFuY2Uuc2Nyb2xsaW5nVmlld3MgPT09IG51bGwgfHwgcGFnZVNjcm9sbEluc3RhbmNlLnNjcm9sbGluZ1ZpZXdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTm8gc2Nyb2xsaW5nVmlld3Mgc3BlY2lmaWVkLCB0aHVzIHdlIGNhbid0IGFuaW1hdGUgYW55dGhpbmdcbiAgICAgICAgICAgIGlmIChQYWdlU2Nyb2xsQ29uZmlnLl9sb2dMZXZlbCA+PSAyIHx8IChQYWdlU2Nyb2xsQ29uZmlnLl9sb2dMZXZlbCA+PSAxICYmIGlzRGV2TW9kZSgpKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTm8gc2Nyb2xsaW5nVmlld3Mgc3BlY2lmaWVkLCB0aGlzIG5nMi1wYWdlLXNjcm9sbCBkb2VzIG5vdCBrbm93IHdoaWNoIERPTSBlbGVtZW50cyB0byBzY3JvbGwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnRTY3JvbGxQb3NpdGlvbkZvdW5kID0gZmFsc2U7XG4gICAgICAgIC8vIFJlc2V0IHN0YXJ0IHNjcm9sbCBwb3NpdGlvbiB0byAwLiBJZiBhbnkgb2YgdGhlIHNjcm9sbGluZ1ZpZXdzIGhhcyBhIGRpZmZlcmVudCBvbmUsIGl0IHdpbGwgYmUgZXh0cmFjdGVkIG5leHRcbiAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLnN0YXJ0U2Nyb2xsUG9zaXRpb24gPSAwO1xuICAgICAgICAvLyBHZXQgdGhlIHN0YXJ0IHNjcm9sbCBwb3NpdGlvbiBmcm9tIHRoZSBzY3JvbGxpbmdWaWV3cyAoZS5nLiBpZiB0aGUgdXNlciBhbHJlYWR5IHNjcm9sbGVkIGRvd24gdGhlIGNvbnRlbnQpXG4gICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5zY3JvbGxpbmdWaWV3cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxpbmdWaWV3KSB7XG4gICAgICAgICAgICBpZiAoVXRpbC5pc1VuZGVmaW5lZE9yTnVsbChzY3JvbGxpbmdWaWV3KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnQgdmFsdWUgb2YgdGhlIGZpcnN0IHNjcm9sbGluZ1ZpZXcgdGhhdCByZXR1cm5zIGEgdmFsdWUgZm9yIGl0cyBcInNjcm9sbFRvcFwiXG4gICAgICAgICAgICAvLyBvciBcInNjcm9sbExlZnRcIiBwcm9wZXJ0eSB0aGF0IGlzIG5vdCB1bmRlZmluZWQgYW5kIHVuZXF1YWwgdG8gMFxuICAgICAgICAgICAgdmFyIHNjcm9sbFBvc2l0aW9uID0gcGFnZVNjcm9sbEluc3RhbmNlLmdldFNjcm9sbFByb3BlcnR5VmFsdWUoc2Nyb2xsaW5nVmlldyk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0U2Nyb2xsUG9zaXRpb25Gb3VuZCAmJiBzY3JvbGxQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgc2Nyb2xsaW5nVmlldyB0aGF0IGRvZXMgbm90IGhhdmUgc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnQgMFxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgc2Nyb2xsIHBvc2l0aW9uIHZhbHVlLCBhcyB0aGlzIHdpbGwgYmUgb3VyIHN0YXJ0U2Nyb2xsUG9zaXRpb25cbiAgICAgICAgICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2Uuc3RhcnRTY3JvbGxQb3NpdGlvbiA9IHNjcm9sbFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHN0YXJ0U2Nyb2xsUG9zaXRpb25Gb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcGFnZVNjcm9sbE9mZnNldCA9IHBhZ2VTY3JvbGxJbnN0YW5jZS5nZXRDdXJyZW50T2Zmc2V0KCk7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdGFyZ2V0IHBvc2l0aW9uIHRoYXQgdGhlIHNjcm9sbCBhbmltYXRpb24gc2hvdWxkIGdvIHRvXG4gICAgICAgIHZhciBzY3JvbGxUYXJnZXRQb3NpdGlvbiA9IHBhZ2VTY3JvbGxJbnN0YW5jZS5leHRyYWN0U2Nyb2xsVGFyZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLnRhcmdldFNjcm9sbFBvc2l0aW9uID0gTWF0aC5yb3VuZCgocGFnZVNjcm9sbEluc3RhbmNlLnZlcnRpY2FsU2Nyb2xsaW5nID8gc2Nyb2xsVGFyZ2V0UG9zaXRpb24udG9wIDogc2Nyb2xsVGFyZ2V0UG9zaXRpb24ubGVmdCkgLSBwYWdlU2Nyb2xsT2Zmc2V0KTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSB3ZSBuZWVkIHRvIGdvIGluIHRvdGFsXG4gICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5kaXN0YW5jZVRvU2Nyb2xsID0gcGFnZVNjcm9sbEluc3RhbmNlLnRhcmdldFNjcm9sbFBvc2l0aW9uIC0gcGFnZVNjcm9sbEluc3RhbmNlLnN0YXJ0U2Nyb2xsUG9zaXRpb247XG4gICAgICAgIGlmIChpc05hTihwYWdlU2Nyb2xsSW5zdGFuY2UuZGlzdGFuY2VUb1Njcm9sbCkpIHtcbiAgICAgICAgICAgIC8vIFdlIHdlcmVuJ3QgYWJsZSB0byBmaW5kIHRoZSB0YXJnZXQgcG9zaXRpb24sIG1heWJlIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0P1xuICAgICAgICAgICAgaWYgKFBhZ2VTY3JvbGxDb25maWcuX2xvZ0xldmVsID49IDIgfHwgKFBhZ2VTY3JvbGxDb25maWcuX2xvZ0xldmVsID49IDEgJiYgaXNEZXZNb2RlKCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1Njcm9sbGluZyBub3QgcG9zc2libGUsIGFzIHdlIGNhblxcJ3QgZmluZCB0aGUgc3BlY2lmaWVkIHRhcmdldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLmZpcmVFdmVudChmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UncmUgYXQgdGhlIGZpbmFsIGRlc3RpbmF0aW9uIGFscmVhZHlcbiAgICAgICAgLy8gT1Igd2UgbmVlZCB0byBzY3JvbGwgZG93biBidXQgYXJlIGFscmVhZHkgYXQgdGhlIGVuZFxuICAgICAgICAvLyBPUiB3ZSBuZWVkIHRvIHNjcm9sbCB1cCBidXQgYXJlIGF0IHRoZSB0b3AgYWxyZWFkeVxuICAgICAgICB2YXIgYWxsUmVhZHlBdERlc3RpbmF0aW9uID0gTWF0aC5hYnMocGFnZVNjcm9sbEluc3RhbmNlLmRpc3RhbmNlVG9TY3JvbGwpIDwgUGFnZVNjcm9sbENvbmZpZy5fbWluU2Nyb2xsRGlzdGFuY2U7XG4gICAgICAgIC8vIENoZWNrIGhvdyBsb25nIHdlIG5lZWQgdG8gc2Nyb2xsIGlmIGEgc3BlZWQgb3B0aW9uIGlzIGdpdmVuXG4gICAgICAgIC8vIERlZmF1bHQgZXhlY3V0aW9uRHVyYXRpb24gaXMgdGhlIHNwZWNpZmllZCBkdXJhdGlvblxuICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuZXhlY3V0aW9uRHVyYXRpb24gPSBwYWdlU2Nyb2xsSW5zdGFuY2UuZHVyYXRpb247XG4gICAgICAgIC8vIE1heWJlIHdlIG5lZWQgdG8gcGF5IGF0dGVudGlvbiB0byB0aGUgc3BlZWQgb3B0aW9uP1xuICAgICAgICBpZiAoIVV0aWwuaXNVbmRlZmluZWRPck51bGwocGFnZVNjcm9sbEluc3RhbmNlLnNwZWVkKSAmJiBVdGlsLmlzVW5kZWZpbmVkT3JOdWxsKHBhZ2VTY3JvbGxJbnN0YW5jZS5kdXJhdGlvbikpIHtcbiAgICAgICAgICAgIC8vIFNwZWVkIG9wdGlvbiBpcyBzZXQgYW5kIG5vIGR1cmF0aW9uID0+IGNhbGN1bGF0ZSBkdXJhdGlvbiBiYXNlZCBvbiBzcGVlZCBhbmQgc2Nyb2xsIGRpc3RhbmNlXG4gICAgICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuZXhlY3V0aW9uRHVyYXRpb24gPSBNYXRoLmFicyhwYWdlU2Nyb2xsSW5zdGFuY2UuZGlzdGFuY2VUb1Njcm9sbCkgLyBwYWdlU2Nyb2xsSW5zdGFuY2Uuc3BlZWQgKiAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHNob3VsZCBnbyB0aGVyZSBkaXJlY3RseSwgYXMgb3VyIFwiYW5pbWF0aW9uXCIgd291bGQgaGF2ZSBvbmUgYmlnIHN0ZXBcbiAgICAgICAgLy8gb25seSBhbnl3YXkgYW5kIHRoaXMgd2F5IHdlIHNhdmUgdGhlIGludGVydmFsIHN0dWZmXG4gICAgICAgIHZhciB0b29TaG9ydEludGVydmFsID0gcGFnZVNjcm9sbEluc3RhbmNlLmV4ZWN1dGlvbkR1cmF0aW9uIDw9IFBhZ2VTY3JvbGxDb25maWcuX2ludGVydmFsO1xuICAgICAgICBpZiAoYWxsUmVhZHlBdERlc3RpbmF0aW9uIHx8IHRvb1Nob3J0SW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGlmIChQYWdlU2Nyb2xsQ29uZmlnLl9sb2dMZXZlbCA+PSAyIHx8IChQYWdlU2Nyb2xsQ29uZmlnLl9sb2dMZXZlbCA+PSAxICYmIGlzRGV2TW9kZSgpKSkge1xuICAgICAgICAgICAgICAgIGlmIChhbGxSZWFkeUF0RGVzdGluYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1Njcm9sbGluZyBub3QgcG9zc2libGUsIGFzIHdlIGNhblxcJ3QgZ2V0IGFueSBjbG9zZXIgdG8gdGhlIGRlc3RpbmF0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU2Nyb2xsIGR1cmF0aW9uIHNob3J0ZXIgdGhhdCBpbnRlcnZhbCBsZW5ndGgsIGp1bXBpbmcgdG8gdGFyZ2V0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLnNldFNjcm9sbFBvc2l0aW9uKHBhZ2VTY3JvbGxJbnN0YW5jZS50YXJnZXRTY3JvbGxQb3NpdGlvbik7XG4gICAgICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuZmlyZUV2ZW50KHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBpbnRlcnJ1cHQgbGlzdGVuZXJzIGlmIHdlIHdhbnQgYW4gaW50ZXJydXB0aWJsZSBzY3JvbGwgYW5pbWF0aW9uXG4gICAgICAgIGlmIChwYWdlU2Nyb2xsSW5zdGFuY2UuaW50ZXJydXB0aWJsZSB8fFxuICAgICAgICAgICAgKFV0aWwuaXNVbmRlZmluZWRPck51bGwocGFnZVNjcm9sbEluc3RhbmNlLmludGVycnVwdGlibGUpICYmIFBhZ2VTY3JvbGxDb25maWcuZGVmYXVsdEludGVycnVwdGlibGUpKSB7XG4gICAgICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuYXR0YWNoSW50ZXJydXB0TGlzdGVuZXJzKHRoaXMub25JbnRlcnJ1cHRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGV0J3MgZ2V0IHN0YXJ0ZWQsIGdldCB0aGUgc3RhcnQgdGltZS4uLlxuICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2Uuc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIC8vIC4uIGFuZCBjYWxjdWxhdGUgdGhlIGVuZCB0aW1lICh3aGVuIHdlIG5lZWQgdG8gZmluaXNoIGF0IGxhc3QpXG4gICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5lbmRUaW1lID0gcGFnZVNjcm9sbEluc3RhbmNlLnN0YXJ0VGltZSArIHBhZ2VTY3JvbGxJbnN0YW5jZS5leGVjdXRpb25EdXJhdGlvbjtcbiAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLnRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKF9wYWdlU2Nyb2xsSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIC8vIFRha2UgdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIG5ldyBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgICAgIHZhciBuZXdTY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciBzdG9wTm93ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoX3BhZ2VTY3JvbGxJbnN0YW5jZS5lbmRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UncmUgb3ZlciB0aGUgdGltZSBhbHJlYWR5LCBzbyBnbyB0aGUgdGFyZ2V0U2Nyb2xsUG9zaXRpb24gKGFrYSBkZXN0aW5hdGlvbilcbiAgICAgICAgICAgICAgICBuZXdTY3JvbGxQb3NpdGlvbiA9IF9wYWdlU2Nyb2xsSW5zdGFuY2UudGFyZ2V0U2Nyb2xsUG9zaXRpb247XG4gICAgICAgICAgICAgICAgc3RvcE5vdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHNjcm9sbCBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgY3VycmVudCB0aW1lIHVzaW5nIHRoZSBlYXNpbmcgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBuZXdTY3JvbGxQb3NpdGlvbiA9IE1hdGgucm91bmQoX3BhZ2VTY3JvbGxJbnN0YW5jZS5lYXNpbmdMb2dpYy5lYXNlKGN1cnJlbnRUaW1lIC0gX3BhZ2VTY3JvbGxJbnN0YW5jZS5zdGFydFRpbWUsIF9wYWdlU2Nyb2xsSW5zdGFuY2Uuc3RhcnRTY3JvbGxQb3NpdGlvbiwgX3BhZ2VTY3JvbGxJbnN0YW5jZS5kaXN0YW5jZVRvU2Nyb2xsLCBfcGFnZVNjcm9sbEluc3RhbmNlLmV4ZWN1dGlvbkR1cmF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdGhlIG5ldyBzY3JvbGxQb3NpdGlvbiB0byBhbGwgc2Nyb2xsaW5nVmlld3MgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghX3BhZ2VTY3JvbGxJbnN0YW5jZS5zZXRTY3JvbGxQb3NpdGlvbihuZXdTY3JvbGxQb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIHRoZSBuZXcgc2Nyb2xsVG9wL3Njcm9sbExlZnQgdmFsdWUgZmFpbGVkIGZvciBhbGwgU2Nyb2xsaW5nVmlld3NcbiAgICAgICAgICAgICAgICAvLyBlYXJseSBzdG9wIHRoZSBzY3JvbGwgYW5pbWF0aW9uIHRvIHNhdmUgcmVzb3VyY2VzXG4gICAgICAgICAgICAgICAgc3RvcE5vdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBdCB0aGUgZW5kIGRvIHRoZSBpbnRlcm5hbCBzdG9wIG1haW50ZW5hbmNlIGFuZCBmaXJlIHRoZSBwYWdlU2Nyb2xsRmluaXNoIGV2ZW50XG4gICAgICAgICAgICAvLyAob3RoZXJ3aXNlIHRoZSBldmVudCBtaWdodCBhcnJpdmUgYXQgXCJ0b28gZWFybHlcIilcbiAgICAgICAgICAgIGlmIChzdG9wTm93KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RvcEludGVybmFsKGZhbHNlLCBfcGFnZVNjcm9sbEluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgUGFnZVNjcm9sbENvbmZpZy5faW50ZXJ2YWwsIHBhZ2VTY3JvbGxJbnN0YW5jZSk7XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBpbnN0YW5jZSBhcyBydW5uaW5nIG9uZVxuICAgICAgICB0aGlzLnJ1bm5pbmdJbnN0YW5jZXMucHVzaChwYWdlU2Nyb2xsSW5zdGFuY2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RvcCBhbGwgcnVubmluZyBzY3JvbGwgYW5pbWF0aW9ucy4gT3B0aW9uYWxseSBsaW1pdCB0byBzdG9wIG9ubHkgdGhlIG9uZXMgb2Ygc3BlY2lmaWMgbmFtZXNwYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFBhZ2VTY3JvbGxTZXJ2aWNlLnByb3RvdHlwZS5zdG9wQWxsID0gZnVuY3Rpb24gKG5hbWVzcGFjZSkge1xuICAgICAgICBpZiAodGhpcy5ydW5uaW5nSW5zdGFuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBzdG9wcGVkU29tZSA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJ1bm5pbmdJbnN0YW5jZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFnZVNjcm9sbEluc3RhbmNlID0gdGhpcy5ydW5uaW5nSW5zdGFuY2VzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChVdGlsLmlzVW5kZWZpbmVkT3JOdWxsKG5hbWVzcGFjZSkgfHwgbmFtZXNwYWNlLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UubmFtZXNwYWNlID09PSBuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFNvbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3BJbnRlcm5hbCh0cnVlLCBwYWdlU2Nyb2xsSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWNyZWFzZSB0aGUgY291bnRlciwgYXMgd2UgcmVtb3ZlZCBhbiBpdGVtIGZyb20gdGhlIGFycmF5IHdlIGl0ZXJhdGUgb3ZlclxuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0b3BwZWRTb21lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFBhZ2VTY3JvbGxTZXJ2aWNlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHBhZ2VTY3JvbGxJbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9wSW50ZXJuYWwodHJ1ZSwgcGFnZVNjcm9sbEluc3RhbmNlKTtcbiAgICB9O1xuICAgIFBhZ2VTY3JvbGxTZXJ2aWNlLmluc3RhbmNlQ291bnRlciA9IDA7XG4gICAgUGFnZVNjcm9sbFNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBQYWdlU2Nyb2xsU2VydmljZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBQYWdlU2Nyb2xsU2VydmljZTtcbn0oKSk7XG5leHBvcnQgeyBQYWdlU2Nyb2xsU2VydmljZSB9O1xuLyogc2luZ2xldG9uIHBhdHRlcm4gdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xMzg1NCAqL1xuZXhwb3J0IGZ1bmN0aW9uIE5HMlBBR0VTQ1JPTExfU0VSVklDRV9QUk9WSURFUl9GQUNUT1JZKHBhcmVudERpc3BhdGNoZXIpIHtcbiAgICByZXR1cm4gcGFyZW50RGlzcGF0Y2hlciB8fCBuZXcgUGFnZVNjcm9sbFNlcnZpY2UoKTtcbn1cbmV4cG9ydCB2YXIgTkcyUEFHRVNDUk9MTF9TRVJWSUNFX1BST1ZJREVSID0ge1xuICAgIHByb3ZpZGU6IFBhZ2VTY3JvbGxTZXJ2aWNlLFxuICAgIGRlcHM6IFtbbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpLCBQYWdlU2Nyb2xsU2VydmljZV1dLFxuICAgIHVzZUZhY3Rvcnk6IE5HMlBBR0VTQ1JPTExfU0VSVklDRV9QUk9WSURFUl9GQUNUT1JZXG59O1xuIl19